为什么要给表加上主键？
为什么加索引后会使查询变快？
为什么加索引后会使写入、修改、删除变慢？
什么情况下要同时在两个字段上建索引？
处理千万级数据需深入了解索引的原理

如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，
即「平衡树」结构，换句话说，就是整个表就变成了一个索引，也就是所谓的「聚集索引」。
这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，
因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置

假如一张表有一亿条数据 ，需要查找其中某一条数据，一条一条的去匹配的话， 
最坏的情况下需要匹配一亿次才能得到结果，用大O标记法就是O(n)最坏时间复杂度，
这一亿次匹配在不经缓存优化的情况下就是一亿次IO开销，以现在磁盘的IO能力和CPU的运算能力， 
有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），
假设这棵树有10层，那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，
用大O标记法就是O(log n)，查找次数是以树的分叉数为底，记录总数的对数，
用程序来表示就是Math.Log(100000000,10)，100000000是记录数，10是树的分叉数

索引能让数据库写入数据的速度下降，因为平衡树这个结构必须一直维持在一个正确的状态，
增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构，
在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销。
非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据， 
而通过非聚集索引（我们平时用的）可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，
不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。

「覆盖索引」，也就是平时所说的复合索引或者多字段索引查询，可以不使用聚集索引就能查询出所需要的数据，
当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。

//建立索引
create index index_birthday on user_info(birthday);
//查询生日在1991年11月1日出生用户的用户名
select user_name from user_info where birthday = '1991-11-1'
首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值
然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置
最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果

我们把birthday字段上的索引改成双字段的覆盖索引
create index index_birthday_and_user_name on user_info(birthday, user_name);
这句SQL语句的执行过程就会变为
通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，
然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 
因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 
通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能 
